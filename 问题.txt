dubbo连接分式:
1.采用zookeeper作为注册中心(适合开发阶段和线上)
2.无注册中心直接连接方式(开发阶段):服务提供方直接连接服务调用发
3.分组连接(一个接口有多个实现类时) 服务提供方给配置分组 服务调用方根据分组进行连接

dubbo连接所使用的协议:
1.dubbo协议:长连接,异步传输,传输的数据小小于100k
2.http协议:
3.redis协议等


zookeeper使用场景:
项目是soa分布式架构,连接方式用到了dubbo的zookeeper作为注册中心,就是说项目一启动服务的提供方就会去
zookeeper注册中心进行注册,dubbo这时就承担着管路服务提供方的角色,如果服务提供方是集群的话dubbo就能知道
每一个服务器的ip和端口,从而服务的调用方就可以访问的.zookeeper还可以承担管理solr集群的任务

企业中怎么做前后端分离的:
前端:pc页面端,iOS端,安卓端;
后端:java后台开发
项目开始前开会制定统一的开发api
前端后后端按照统一的接口api进行开发


企业中redis宕机处理方案:

做redis集群 一组两个一个主机一个备机,主机备机的数据一模一样,平时做心跳检测机制保证redis的高可用

redis的slot曹值范围是0~16383 也就是说最多可以有16384组redis,目前国内没有一个项目可以达到用4万多台redis机器
即便是达到了也可以按照不同的模块不同的项目连接不同的redis集群,进行再次划分
slot曹进行算法然后决定数据存储的位置可以解决高并发

企业中的redis线上部署为啥不设置密码:
Nginx  内网(Tomcat,redis)
一般用户访问都会经过Nginx负载均衡器,再由负载均衡器进行内网的访问,所以一般redis部署在公司的内网上设不设密码
都可以

activeMq消息丢失处理方案:
如何保证消息服务器不丢消息, 也就是不丢数据:
	答: 我们使用的是activemq消息服务器, 它有两种发送模式点对点和订阅发布
	点对点:
		不用管, 消息服务器有内部机制保证绝对不会丢数据.
		原理: 发送方将消息发送给消息服务器后, 消息服务器会将队列中的消息发送给接收方, 接收方接收到
		消息后会给消息服务器返回一个响应, 消息服务器接收到响应后认为消息接收成功, 将队列中这个发送完的
		消息删除, 如果消息服务器在一定时间内没有接受到响应, 则认为消息接收方宕机, 这个时候会将发送完的这个
		消息进行持久化保存, 如果消息接收方服务器从新启动连接消息服务器, 消息服务器会监听到, 会将之前持久化的
		消息从新发送给消息服务器.
	订阅发布:
		订阅发布模式没有实现保证数据安全的机制, 如果消息服务器将消息发送给接收方, 接收方接收到就算接收到了
		没接收到就算丢了, 也不进行持久化.
		
cas和springsecurity:
cas主要做登录认证
springsecurity既可以做登录认证也可以做权限管理
springsecurity和cas结合后登录认证由cas来管理,权限的管理则交给springsecurity

mysql引擎:
MyISAM引擎:(查询快增删改效率低)
不支持事物,插入或更新数据会将整个表锁起来不允许读取,效率会更低一些.支持全文索引
Inodb存储引擎:(查询的时候效率低增删改的时候效率高一些)
支持事物,行级锁,不支持全文索引
memory引擎:
存在内存中 ,在没有redis的情况下当分布式缓存来用,内存的读写效率远远大于硬盘的读写效率

怎样查看线上服务器的日志:
连接到服务器
用Linux命令:tail -f(-f表示实时监控) /usr/local/solr/tomcat/logs/catalina.out

tail -n(-n表示按行监控) 10 /usr/local/solr/tomcat/logs/catalina.out  表示查看前10的日志

缓存穿透问题:
查询一个东西redis中不存在去mysql数据库中查询也不存在,大量的这种查询redis和mysql数据库中都不存在就会给mysql数据库造成大量的访问量,
结果可能数据库压力过高,宕机,这就是缓存的穿透问题.
解决方案:
1.把系统中有可能去数据库查询的数据存放到一个hash中,hash的特点就是查询速度快,用hash来校验,查的时候先去hash中查,如果hash中有再去redis和数据库
中查询,如果hash中没有就直接返回null.不需要再去redis和mysql数据库中查询了.(布隆过滤器,bitmap)
2.还可以采用一个简单粗暴的方法,去查询一个数据返回结果不管存在不存在都在redis中存一份,下次再去查询的时候redis中直接返回null,也可以给数据库
减轻压力(时间短 只有5分钟)
缓存雪崩:
由缓存穿透引起的,高并发的情况下去数据库查询一直为空就会造成数据库的宕机,从而引发雪崩.
解决方案:
1.加锁,在高并发的情况下给数据库加锁,他去redis查取数据库查要一个一个去查,排队去查,没有并发的去查,数据库就可以承受的住(限流)
2.做两级缓存,把不存在的数据也存到缓存中,A1去查查不到(A1为短期),去A2查A2查不到直接返回null(A2为长期),这样就不会穿过缓存去访问数据库
 服务器雪崩效应的处理方案:
 1.服务器发生雪崩效应的原因:
 人为原因:程序某一时段出现某一bug
 服务器负载均衡变化:并发访问量过高,Tomcat承受不住
 某个机器出现故障
 2.解决或缓解服务器雪崩效应的方法:
 1.熔断模式:当有一台服务器挂掉难以承受高并发访问时,给用户提示一个友好信息,禁止用户再次访问其他的服务器 服务不对外开放
 2.隔离模式:相当于一个小岛,小岛燃烧不会涉及周围
 3.限流模式
 
 java中四种修饰符的限制范围: public protected default private
 
 动态代理的两种方式及区别:
 jdk动态代理是由Java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。
 总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效
 （可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。
 还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。
 如果没有上述前提，jdk动态代理不能应用。由此可以看出，jdk动态代理有一定的局限性，
 cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。。
 
对象序列化:
创建一个对象实现Serializable
对象序列化包括如下步骤：
　　1） 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；
　　2） 通过对象输出流的writeObject()方法写对象。

　　对象反序列化的步骤如下：
　　1） 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；
　　2） 通过对象输入流的readObject()方法读取对象。

一个ArrayList在循环过程中删除，会不会出问题，为什么:
会,循环删除会影响后序元素的遍历,可以倒序遍历的方法来删除,
这样即便发生了元素删除也不会影响到后序的元素

@transactional注解在什么情况下会失效，为什么:

@Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。
如果你在 protected、private或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，
也不会抛出任何异常。
默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，
类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。

什么是内存泄漏?
答：一般我们所说的内存泄漏指的是堆内存的泄漏。堆内存是程序从堆中为其分配的，大小任意的，使用完后要显示释放内存。
当应用程序用关键字new 等创建对象时，就从堆中为它分配一块内存，使用完后程序调用free 或者delete 释放该内存，
否则就说该内存就不能被使用，我们就说该内存被泄漏了。

触发器的作用?
 答：触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，
 可以跟踪数据库内的操作从而不允许未经许可的更新和变化。
 可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。
 
维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？
 答：我是这样做的，尽可能使用约束，如check, 主键，外键，非空字段等来约束，这样做效率最高，也最方便。
 其次是使用触发器，这种方法可以保证，
 无论什么业务系统访问数据库都可以保证数据的完整新和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。
 
 约束>触发器>自己编写逻辑'
 
 什么是事物?什么是锁?
 答：事务就是被绑定在一起作为一个逻辑工作单元的SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，
 以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，
 就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID 测试，即原子性，一致性，隔离性和持久性。
 锁是实现事务的关键，锁可以保证事务的完整性和并发性。
 反射原理
 Java虚拟机运行时内存有个叫方法区，主要作用是存储被装载的类的类型信息。每装载一个类的时候，
 java就会创建一个该类的Class对象实例。我们就可以通过这个实例，来访问这个类的信息。
 代理的作用:控制对某个事物的访问 代理对象可以在客户端和目标对象之间起到中介的作用.
redis的持久化机制:
rdb:方便持久,容灾性好,性能好,数据极大是比aof的效率高
aof:安全

什么是值传递和引用传递？
对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。

对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。

JVM的永久代中会发生垃圾回收么？
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。
如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。

数据库连接池是什么意思？
像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。
可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。
在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求


重写equals就必须重写hashcode.
1.new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,
也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。
2.比较两个对象的时候,首先根据他们的hashcode去hash表中找他的对象,当两个对象的hashcode相同,那么就是说他们这两个对象放在Hash表中的同一个key上,
那么他们一定在这个key上的链表上。那么此时就只能根据Object的equal方法来比较这个对象是否equal。当两个对象的hashcode不同的话，肯定他们不能equals.
总结:equals相同的两个对象hashcode一定相等. hashcode 相等的equals返回不一定为true;


rabbitmq交换器:
rountingkey: good.#(log开头都能匹配)
rountingkey: #.log  (log结尾都能匹配)
rountingkey: good.log (只能匹配 good.log)
rabbitmq消费者一直跑着,只要mq服务器中有消息,就把他消费掉.


SQL优化的一些方法:
1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：    
select id from t where num is null    
可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：    
select id from t where num=0  
3.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。  
4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：    
select id from t where num=10 or num=20    
可以这样查询：    
select id from t where num=10    
union all    
select id from t where num=20   
5.in 和 not in 也要慎用，否则会导致全表扫描，如：    
select id from t where num in(1,2,3)    
对于连续的数值，能用 between 就不要用 in 了：    
select id from t where num between 1 and 3    
6.下面的查询也将导致全表扫描：    
select id from t where name like '%abc%'    
7.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。    


事务的作用:保证数据的一致性
项目中事务应该控制在service层.

jvm一共分为五大块:
方法区,虚拟机栈,本地方法栈,堆,程序计数器.

单例模式(懒汉式)
public class God {
    private static God god;

    private God() {
    }

    public static God getInstance() {
        if (null == god) {
            god = new God();
        }
        return god;
    }

}

什么是HTTP协议?
http协议:浏览器和服务器之间数据传输格式的规范.
tcp/ip协议:专注的是客户端和服务器之间数据是否传输成功
http协议:就是在tcp/ip协议基础之上封装的一套协议,专注的是客户端和服务器端数据传输的格式是否一致.


long类型怎么比较是否相等?
a.longValue() == b.longValue()，
或者0 == Long.compare(a, b)；

double类型装换long类型.
double d = 88.88;
long l = Math.round(d);

long类型转换double类型.
long ll = 100L;
double dd = (double) ll;



接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？

答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类









搜索主要分为站内搜索和站外搜索.
站外:百度,guge
站内:淘宝,京东.










 




